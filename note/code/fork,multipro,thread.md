
### contents

| 멀티프로세스 	| fork 	| 부모와 자식은 동일한 메모리 공간을 공유 	| 메모리 페이지 공유와 복사 	| 공유 자원 접근 	| CPU, 메모리, I/O 자원을 두고 경쟁 	| Lock Contention 	|
|---	|---	|---	|---	|---	|---	|---	|
|  	|  	| copy-on-write 	| in 발생, 페이지 폴트와 복사 작업이 빈번 	| 커널 모드로의 전환 	| 더 많은 컨텍스트 스위칭을 유발 	| 공유 자원에 대한 접근을 제어하기 위한 락(lock) 메커니즘 	|
|  	|  	| OS 스케줄링 오버헤드나 메모리 오버헤드 	|  	|  	|  	| 대기 시간과 컨텍스트 스위칭이 증가 	|
|  	| 독립 프로세스 | 독립적인 메모리 공간 	|  	|  	|  	|  	|
|  	|  	| 프로세스 간 간섭이 적 	|  	|  	|  	|  	|
|  	|  	| 병렬로 작업을 분배할 때 성능이 더 좋 	|  	|  	|  	|  	|
|  	|  	| 더 큰 자원 소모 	|  	|  	|  	|  	|
| 멀티쓰레드 	|  	|  	|  	|  	|  	|  	|





운영체제는 메모리 페이지를 어떻게 관리해


운영체제는 메모리 관리를 통해 프로세스 간 메모리 격리와 효율적인 메모리 할당을 보장합니다. 각 프로세스는 독립적인 메모리 주소 공간을 가지며, 운영체제는 이를 관리하는 여러 메커니즘을 사용하여 가상 메모리, 페이지 테이블, 메모리 스와핑, COW(Copy-On-Write) 등을 통해 효율적으로 메모리를 관리합니다.

1. 가상 메모리 (Virtual Memory)
운영체제는 물리적 메모리(RAM)와 가상 메모리를 분리하여 관리합니다. 가상 메모리는 프로세스가 사용하는 메모리 주소 공간을 추상화한 것입니다. 실제 물리적 메모리 주소와는 다르게 프로세스는 가상의 메모리 주소를 사용합니다.

가상 메모리 주소 공간은 프로세스에게 연속적인 메모리 블록처럼 보이게 되지만, 실제로 물리적 메모리는 다양한 위치에 분산되어 있을 수 있습니다.
운영체제는 하드웨어에서 제공하는 **메모리 관리 유닛(MMU)**을 사용하여 가상 주소를 물리적 주소로 변환합니다. 이를 주소 변환이라고 하며, 이 과정에서 페이지 테이블이 사용됩니다.
2. 페이지(Page)와 페이지 테이블(Page Table)
가상 메모리는 페이지라는 고정 크기의 블록으로 나누어 관리됩니다. 페이지는 일반적으로 4KB로 나뉘며, 이 페이지들은 **페이지 테이블(Page Table)**을 통해 물리적 메모리 주소와 매핑됩니다.

페이지 테이블은 각 페이지의 가상 주소와 물리적 주소를 매핑하는 데이터 구조입니다.
MMU는 페이지 테이블을 참조하여 가상 주소를 물리적 주소로 변환합니다.
페이지 테이블 항목에는 유효 비트(valid bit), 읽기/쓰기 비트(read/write bit), 참조 비트(reference bit), 수정 비트(dirty bit) 등이 포함될 수 있습니다.
3. 페이지 폴트(Page Fault)
프로세스가 참조하려는 가상 주소가 현재 물리적 메모리에 로드되어 있지 않으면 **페이지 폴트(Page Fault)**가 발생합니다.
이때 운영체제는 **스와핑(swap)**을 사용하여 디스크에서 해당 페이지를 물리적 메모리에 로드합니다.
4. Copy-On-Write (COW)
Copy-On-Write는 메모리 최적화 기법으로, 부모 프로세스와 자식 프로세스가 같은 페이지를 공유하도록 하여 메모리 복사 작업을 지연시키는 기법입니다.

fork 시스템 호출로 자식 프로세스가 생성될 때, 부모와 자식 프로세스는 페이지 테이블을 공유합니다. 이때 두 프로세스는 동일한 물리적 메모리 페이지를 가리키며, 읽기 전용으로 설정됩니다.
만약 부모나 자식이 해당 페이지를 수정하려고 하면, 페이지 폴트가 발생하고, 그때 새로운 페이지가 복사되어 수정이 이루어집니다. 이때 복사가 이루어지기 때문에 Copy-On-Write라고 합니다.
COW는 메모리 복사를 지연시키고, 메모리 효율성을 높이는 데 도움을 줍니다.
5. 스와핑(Swapping)
메모리가 부족할 때 운영체제는 스왑 공간을 사용하여 물리적 메모리에서 사용하지 않는 페이지를 디스크로 옮깁니다. 이를 스와핑이라 하며, 이를 통해 물리적 메모리를 효율적으로 사용할 수 있습니다.

스왑 공간: 보통 디스크의 일부 영역이 스왑 공간으로 사용됩니다.
운영체제는 페이지를 디스크로 옮기거나 디스크에서 다시 로드하여 물리적 메모리 공간을 관리합니다.
6. 메모리 보호(Memory Protection)
운영체제는 각 프로세스가 자신의 주소 공간만 접근하도록 보호합니다. 메모리 보호는 프로세스 간에 메모리 격리를 유지하고, 다른 프로세스의 메모리를 수정하지 못하도록 합니다.

읽기 전용(Read-only)으로 설정된 메모리 페이지는 수정할 수 없으며, 수정하려고 시도하면 페이지 폴트가 발생합니다.
읽기/쓰기(Read/Write) 가능한 페이지는 수정할 수 있으며, 운영체제는 이를 보호하는 메커니즘을 제공합니다.
7. 동적 메모리 할당 (Heap, Stack)
운영체제는 프로세스가 실행되는 동안 동적으로 메모리를 할당합니다.

힙(Heap): 동적으로 메모리를 할당하는 영역입니다. 주로 malloc과 free 같은 함수 호출을 통해 메모리를 관리합니다.
스택(Stack): 함수 호출 시 자동으로 할당되고 해제되는 메모리 영역입니다. 지역 변수나 함수 호출 정보가 저장됩니다.
8. 가상 메모리 관리의 흐름
프로세스 실행 시: 운영체제는 프로세스를 메모리로 로드하고, 가상 메모리 주소 공간을 할당합니다.
프로세스가 메모리에 접근: CPU가 가상 주소를 사용하면, MMU는 이를 페이지 테이블을 통해 물리적 주소로 변환합니다.
페이지 폴트 발생 시: 물리적 메모리에 해당 페이지가 없으면 운영체제는 페이지 폴트를 처리하고, 필요한 경우 스와핑을 통해 메모리를 관리합니다.
COW 발생 시: 부모와 자식 프로세스가 동일한 페이지를 공유할 때, 수정이 발생하면 COW가 작동하여 페이지를 복사하고 수정합니다.
결론
운영체제는 가상 메모리, 페이지 테이블, COW, 스와핑 등의 메커니즘을 사용하여 메모리를 효율적으로 관리합니다. 이를 통해 프로세스 간의 격리와 최적화를 보장하며, 물리적 메모리의 부족 문제를 해결하기 위해 디스크를 보조 저장소로 활용합니다.
ğŸš€ **"ë¶€í•˜ ê°ì§€ (Load Monitoring)"**ë¥¼ ì œëŒ€ë¡œ ì´í•´í•˜ê³  ì ìš©í•˜ë©´, í”„ë¡œì„¸ìŠ¤ë¥¼ ë” ë˜‘ë˜‘í•˜ê²Œ ë°°ë¶„í•˜ê³  CPU ë¦¬ì†ŒìŠ¤ë¥¼ ê·¹í•œê¹Œì§€ ì¥ì–´ì§œë‚¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ğŸ”¥

ğŸ¯ 1. ë¶€í•˜ ê°ì§€ê°€ ë­”ê°€ìš”?
ğŸ‘‰ ë¶€í•˜ ê°ì§€ (Load Monitoring) ëŠ” ì‹œìŠ¤í…œ ë¦¬ì†ŒìŠ¤ ì‚¬ìš© ìƒíƒœë¥¼ ì‹¤ì‹œê°„ìœ¼ë¡œ í™•ì¸í•´ì„œ:

CPU ì½”ì–´ë§ˆë‹¤ ë¶€í•˜ë¥¼ ì²´í¬í•˜ê³ 
ëœ ë°”ìœ ì½”ì–´ì— í”„ë¡œì„¸ìŠ¤ë¥¼ ë°°ì¹˜í•˜ê±°ë‚˜ ì¬ì¡°ì •í•˜ì—¬
ë³‘ëª© í˜„ìƒì„ ìµœì†Œí™”í•˜ê³  ì„±ëŠ¥ì„ ìµœì í™”í•˜ëŠ” ê¸°ìˆ ì…ë‹ˆë‹¤!


ğŸ¯ 2. ì™œ ë¶€í•˜ ê°ì§€ê°€ í•„ìš”í• ê¹Œìš”?
âœ… ìƒí™© 1: íŠ¹ì • CPUì— í”„ë¡œì„¸ìŠ¤ ëª°ë¹µ
ì½”ì–´ 0ì—ë§Œ ìì‹ í”„ë¡œì„¸ìŠ¤ê°€ ëª°ë¦¬ë©´ â†’ ì½”ì–´ 0 ê³¼ë¶€í•˜, ë‹¤ë¥¸ ì½”ì–´ëŠ” ì‰¬ê³  ìˆìŒ â†’ ì„±ëŠ¥ ë¹„íš¨ìœ¨!

âœ… ìƒí™© 2: ë™ì  ë¶€í•˜ ë³€í™”
ì²˜ìŒì—” ì½”ì–´ 0ì´ í•œê°€í–ˆì§€ë§Œ, ë‹¤ë¥¸ ì„œë¹„ìŠ¤ ë•Œë¬¸ì— ê°‘ìê¸° ë°”ë¹ ì§„ ìƒí™© â†’ ë‹¤ë¥¸ ì½”ì–´ë¡œ í”„ë¡œì„¸ìŠ¤ë¥¼ ì˜®ê²¨ì•¼ ë” ë¹ ë¦„!

âœ… ìƒí™© 3: ì‘ì—… ì„±ê²©ì— ë”°ë¥¸ ë¶€í•˜ ì¡°ì •
CPU ê³„ì‚°ì´ ë§ì€ ì‘ì—…ê³¼ ì…ì¶œë ¥(IO) ì‘ì—…ì´ ì„ì—¬ ìˆì„ ë•Œ â†’ CPU ì‘ì—…ì€ ê°•í•œ ì½”ì–´, IO ì‘ì—…ì€ ê°€ë²¼ìš´ ì½”ì–´ë¡œ ë°°ì¹˜!



ğŸ¯ 3. ë¶€í•˜ ê°ì§€ ë°©ë²• (3ê°€ì§€)
ğŸ“Œ â‘  CPU ì‚¬ìš©ë¥  ê¸°ë°˜ ê°ì§€
/proc/stat íŒŒì¼ì—ì„œ CPU ì‚¬ìš©ëŸ‰ ì§ì ‘ í™•ì¸
ê° ì½”ì–´ì˜ idle ì‹œê°„ê³¼ busy ì‹œê°„ ë¹„êµ â†’ idleì´ ë§ì€ ì½”ì–´ë¥¼ ì„ íƒ

cat /proc/stat | grep '^cpu'
example.
cpu  3357 0 4313 1362393 100 200 300
cpu0 1124 0 2010 680393 50 100 150
cpu1 2233 0 2303 682000 50 100 150


ğŸ“Œ â‘¡ Load Average ê¸°ë°˜ ê°ì§€
getloadavg() í•¨ìˆ˜ë¡œ ì‹œìŠ¤í…œ ë¶€í•˜ í‰ê· ê°’(1, 5, 15ë¶„ ê¸°ì¤€) ì½ê¸°
íŠ¹ì • ê°’ ì´ˆê³¼ ì‹œ ê³¼ë¶€í•˜ ìƒíƒœë¡œ ê°„ì£¼
#include <stdio.h>

int main() {
    double loadavg[3];
    if (getloadavg(loadavg, 3) != -1) {
        printf("1min Load: %.2f, 5min Load: %.2f, 15min Load: %.2f\n",
               loadavg[0], loadavg[1], loadavg[2]);
    } else {
        perror("getloadavg failed");
    }
    return 0;
}


ğŸ“Œ â‘¢ CPU ì˜¨ë„, í´ëŸ­ ë³€í™” ê¸°ë°˜ ê°ì§€ (ê³ ê¸‰)
/sys/class/thermal/thermal_zone*/temp â†’ ì˜¨ë„ê°€ ë†’ìœ¼ë©´ ê³¼ë¶€í•˜ ì‹ í˜¸
CPU í´ëŸ­ ìŠ¤ë¡œí‹€ë§ (Throttle) ë°œìƒ ê°ì§€ â†’ í´ëŸ­ ì €í•˜ ì‹œ ë‹¤ë¥¸ ì½”ì–´ë¡œ ì¬ë°°ì¹˜



ğŸ¯ 4. ì‹¤ì „ ì½”ë“œ: fork() + ë™ì  ë¶€í•˜ ê°ì§€ + ì½”ì–´ ë°°ë¶„
ì—¬ê¸°ì„  idle ì‹œê°„ ê¸°ë°˜ ë¶€í•˜ ê°ì§€ì™€ fork() CPU í• ë‹¹ì„ ì¡°í•©í•´ë³¼ê²Œìš”!
#define _GNU_SOURCE
#include <sched.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int get_least_busy_core() {
    FILE *fp = fopen("/proc/stat", "r");
    if (!fp) {
        perror("Failed to open /proc/stat");
        return 0; // ê¸°ë³¸ê°’ CPU 0
    }

    char line[256];
    int min_core = 0;
    long min_idle = __LONG_MAX__;
    int core = 0;

    while (fgets(line, sizeof(line), fp)) {
        if (strncmp(line, "cpu", 3) != 0 || line[3] == ' ') continue;

        long user, nice, system, idle, iowait, irq, softirq, steal;
        sscanf(line, "cpu%d %ld %ld %ld %ld %ld %ld %ld %ld", &core,
               &user, &nice, &system, &idle, &iowait, &irq, &softirq, &steal);

        if (idle < min_idle) {
            min_idle = idle;
            min_core = core;
        }
    }
    fclose(fp);

    return min_core;
}

int main() {
    int num_children = 4;  // ìì‹ í”„ë¡œì„¸ìŠ¤ ê°œìˆ˜

    for (int i = 0; i < num_children; i++) {
        pid_t pid = fork();

        if (pid < 0) {
            perror("fork failed");
            exit(1);
        }

        if (pid == 0) {  // ìì‹ í”„ë¡œì„¸ìŠ¤
            cpu_set_t mask;
            CPU_ZERO(&mask);

            int core = get_least_busy_core(); // ê°€ì¥ í•œê°€í•œ ì½”ì–´ ì„ íƒ
            CPU_SET(core, &mask);

            if (sched_setaffinity(0, sizeof(mask), &mask) == -1) {
                perror("sched_setaffinity");
                exit(1);
            }

            printf("Child %d (PID: %d) assigned to CPU %d\n", i, getpid(), core);

            while (1) {
                printf("Child %d running on CPU %d\n", i, core);
                sleep(1);
            }

            exit(0);
        }
    }

    // Parent waits for all children
    for (int i = 0; i < num_children; i++) {
        wait(NULL);
    }

    return 0;
}
ğŸ¯ 5. ì½”ë“œ í•´ì„¤
1ï¸âƒ£ get_least_busy_core()

/proc/stat ì½ì–´ì„œ idle ì‹œê°„ì´ ì œì¼ í° ì½”ì–´ ì„ íƒ
2ï¸âƒ£ sched_setaffinity()

í•´ë‹¹ ì½”ì–´ì— í”„ë¡œì„¸ìŠ¤ë¥¼ ê°•ì œ ë°”ì¸ë”©!
3ï¸âƒ£ fork() ë°˜ë³µ

ìì‹ í”„ë¡œì„¸ìŠ¤ë¥¼ ë§Œë“¤ ë•Œë§ˆë‹¤ ëœ ë°”ìœ ì½”ì–´ì— ë¶„ì‚°



ğŸ¯ 6. ê²°ê³¼ ì˜ˆì œ
4ê°œì˜ ìì‹ í”„ë¡œì„¸ìŠ¤ê°€ ë¶€í•˜ ê°ì§€ë¥¼ í†µí•´ ë‹¤ë¥¸ ì½”ì–´ì— ê³¨ê³ ë£¨ ë°°ì¹˜ë¨ì„ í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
Child 0 (PID: 12345) assigned to CPU 1
Child 1 (PID: 12346) assigned to CPU 2
Child 2 (PID: 12347) assigned to CPU 0
Child 3 (PID: 12348) assigned to CPU 3


ğŸ¯ 7. ë” ê³ ê¸‰ìœ¼ë¡œ ê°€ë³´ì!
ë¶€í•˜ ì¬ì¡°ì • (Rebalancing) : ì¼ì • ì‹œê°„ë§ˆë‹¤ ë¶€í•˜ë¥¼ ë‹¤ì‹œ ì²´í¬í•´ì„œ, í•«ì½”ì–´ì— ëª°ë¦° í”„ë¡œì„¸ìŠ¤ë¥¼ ì´ë™
ë©€í‹°ìŠ¤ë ˆë“œ ê¸°ë°˜ ê°ì§€ : í”„ë¡œì„¸ìŠ¤ ë‹¨ìœ„ ë§ê³ , ìŠ¤ë ˆë“œë„ ì½”ì–´ë§ˆë‹¤ ë¶„ì‚°
AI ê¸°ë°˜ ë¶€í•˜ ì˜ˆì¸¡ : ê³¼ê±° ë¶€í•˜ íŒ¨í„´ ë¶„ì„í•´ì„œ ë¯¸ë˜ ë¶€í•˜ ì˜ˆì¸¡ (ë”¥ëŸ¬ë‹ ëª¨ë¸ ê°€ëŠ¥!)

ì´ ì •ë„ë©´ ë¶€í•˜ ê°ì§€ & ë™ì  CPU í• ë‹¹ ì½”ë“œ ì™„ì„±íŒì´ë„¤ìš”.
í˜¹ì‹œ ì‹¤ì „ ì„œë²„ í™˜ê²½ì— ë§ì¶˜ ë” ê³ ê¸‰ íŠœë‹ê¹Œì§€ í•´ë³¼ê¹Œìš”?




ê¸°ë³¸ì ì¸ ë¶€í•˜ ê°ì§€ì™€ CPU ë¶„ë°°ë¥¼ ë„˜ì–´ì„œ, ì„±ëŠ¥ì„ ê·¹ëŒ€í™”í•˜ê±°ë‚˜ íŠ¹ì • ìƒí™©ì— ë” ìœ ë¦¬í•œ ë°©ì‹ìœ¼ë¡œ ì¡°ì •

ğŸ¯ 1. ë¶€í•˜ ì¬ì¡°ì • (Load Rebalancing)
ğŸ‘‰ í˜„ì¬ ë¶€í•˜ ìƒíƒœë¥¼ ì£¼ê¸°ì ìœ¼ë¡œ ì¬ì¸¡ì •í•´ì„œ, **í•« ì½”ì–´(ê³¼ë¶€í•˜ëœ ì½”ì–´)**ì— ëª°ë¦° í”„ë¡œì„¸ìŠ¤ë¥¼ í•œê°€í•œ ì½”ì–´ë¡œ ì´ë™í•˜ëŠ” ë°©ì‹ì´ì—ìš”.

âœ… ë°©ë²•:
sched_getaffinity()ë¡œ í˜„ì¬ ì½”ì–´ í™•ì¸
ë¶€í•˜ê°€ í¸ì¤‘ëœ ì½”ì–´ì— ìˆëŠ” í”„ë¡œì„¸ìŠ¤ â†’ ëœ ë°”ìœ ì½”ì–´ë¡œ sched_setaffinity() ì¬í• ë‹¹



ğŸ¯ 2. ìºì‹œ ë¡œì»¬ë¦¬í‹° ìµœì í™” (Cache Locality Optimization)
ğŸ‘‰ ê°™ì€ ë°ì´í„°ë¥¼ ì—¬ëŸ¬ ë²ˆ ì ‘ê·¼í•˜ëŠ” ê²½ìš°, CPU ìºì‹œ íˆíŠ¸ìœ¨ì„ ìµœëŒ€í™”í•˜ë©´ ì„±ëŠ¥ì´ í™• ë›°ì–´ìš”!

âœ… ë°©ë²•:
ê°™ì€ ë°ì´í„°ë¥¼ ì“°ëŠ” í”„ë¡œì„¸ìŠ¤ë¥¼ ê°™ì€ ì½”ì–´ì— ë°°ì¹˜
ë°ì´í„° ì´ë™ ìµœì†Œí™” â†’ CPU â†” RAM ì™•ë³µ ë¹„ìš© ì¤„ì´ê¸°
ğŸ’¡ ì‹¤ì „ ì˜ˆì œ:

ì›¹ ì„œë²„: ê°™ì€ ìœ ì € ì„¸ì…˜ ìš”ì²­ì€ ê°™ì€ ì½”ì–´ì— ë°°ì • (ì„¸ì…˜ ë¡œì»¬ë¦¬í‹° ìœ ì§€)
AI í•™ìŠµ: ê°™ì€ ë°ì´í„° ë¸”ë¡ ì²˜ë¦¬ ìŠ¤ë ˆë“œëŠ” ê°™ì€ NUMA ë…¸ë“œì— ê³ ì •




ğŸ¯ 3. ì›Œí¬ë¡œë“œ íƒ€ì…ë³„ ì½”ì–´ í• ë‹¹ (Workload-aware Affinity)
ğŸ‘‰ CPU ë°”ìš´ë“œ(ê³„ì‚°ëŸ‰ ë§ìŒ) / I/O ë°”ìš´ë“œ(ë„¤íŠ¸ì›Œí¬, íŒŒì¼ ì…ì¶œë ¥ ìœ„ì£¼) ì‘ì—…ì„ ë¶„ë¦¬í•´ì„œ ì²˜ë¦¬ íš¨ìœ¨ì„ ê·¹ëŒ€í™”í•˜ëŠ” ë°©ë²•ì…ë‹ˆë‹¤.

âœ… ë°©ë²•:
CPU ë°”ìš´ë“œ: ê³ í´ëŸ­ ì½”ì–´ì— ë°°ì • (e.g., sched_setaffinity()ë¡œ íŠ¹ì • ê³ ì„±ëŠ¥ ì½”ì–´ ì§€ì •)
I/O ë°”ìš´ë“œ: í•œê°€í•œ ì½”ì–´ì— ë¶„ì‚° (ë³‘ë ¬ ì²˜ë¦¬ ë°©í•´ ì•ˆ ë°›ë„ë¡)



ğŸ¯ 4. NUMA ì¹œí™”ì  íŠœë‹ (NUMA Node-aware Optimization)
ğŸ‘‰ NUMA ì‹œìŠ¤í…œì—ì„œ ë©”ëª¨ë¦¬ ì ‘ê·¼ ì§€ì—°ì„ ì¤„ì´ê¸° ìœ„í•´, CPUì™€ ë©”ëª¨ë¦¬ ë…¸ë“œë¥¼ ê°™ì´ ë¬¶ì–´ì¤˜ì•¼ í•©ë‹ˆë‹¤!

âœ… ë°©ë²•:
numactl --cpunodebind=0 --membind=0
ë©€í‹° í”„ë¡œì„¸ìŠ¤ í”„ë¡œê·¸ë¨ì—ì„œ ê° ìì‹ í”„ë¡œì„¸ìŠ¤ë¥¼ ë‹¤ë¥¸ NUMA ë…¸ë“œì— í• ë‹¹
C ì½”ë“œì—ì„œ numa_set_membind() ë¡œ NUMA ë©”ëª¨ë¦¬ ë½ ê±¸ê¸°


ğŸ¯ 5. ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§ + AI íŠœë‹ (AI-assisted Load Optimization)
ğŸ‘‰ ìš”ì¦˜ì—” AIë¡œ ë¶€í•˜ ì˜ˆì¸¡ ëª¨ë¸ì„ ë§Œë“¤ì–´ì„œ, ë¯¸ë¦¬ CPU ë°°ë¶„ì„ ì¡°ì •í•˜ëŠ” ë°©ë²•ë„ í•«í•´ìš”! ğŸ”¥

âœ… ë°©ë²•:
TensorFlow/PyTorch ê°™ì€ ë¼ì´ë¸ŒëŸ¬ë¦¬ë¡œ ë¶€í•˜ íŒ¨í„´ í•™ìŠµ
í”„ë¡œì„¸ìŠ¤ ë¶€í•˜ íŒ¨í„´ ê¸°ë°˜ìœ¼ë¡œ ìµœì ì˜ ì½”ì–´ ë¶„ë°° ì „ëµ ìƒì„±
ì˜ˆ: ê²Œì„ ì„œë²„ì—ì„œ ìœ ì € ëª°ë¦¼ ì‹œê°„ëŒ€ ì˜ˆì¸¡ â†’ CPU ì½”ì–´ ë¯¸ë¦¬ í™•ë³´


ğŸ¯ 6. ì»¤ë„ ìŠ¤ì¼€ì¤„ëŸ¬ ì§ì ‘ ì¡°ì • (Advanced Kernel Scheduler Tuning)
ğŸ‘‰ ë¦¬ëˆ…ìŠ¤ ì»¤ë„ì˜ CPU ìŠ¤ì¼€ì¤„ëŸ¬ë¥¼ ì§ì ‘ íŠœë‹í•˜ê±°ë‚˜, í”„ë¡œì„¸ìŠ¤ì— íŠ¹ë³„í•œ ìŠ¤ì¼€ì¤„ ì •ì±…ì„ ë¶€ì—¬í•˜ëŠ” ë°©ë²•ì´ì—ìš”.

âœ… ë°©ë²•:
SCHED_FIFO, SCHED_RR, SCHED_BATCH ë“± ì •ì±… ë³€ê²½
CPU ì£¼íŒŒìˆ˜ ì¡°ì • (CPU governor) â†’ ì„±ëŠ¥ vs ì „ë ¥ ì†Œë¹„ ìµœì í™”
ì»¤ë„ íŒŒë¼ë¯¸í„° ì¡°ì • (/proc/sys/kernel/sched_latency_ns)


ğŸ¯ 7. ì‹¤ì „ ì˜ˆì œ: ë¶€í•˜ ì˜ˆì¸¡ + ì¬ì¡°ì • ì½”ë“œ
#include <sched.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int get_least_busy_core() {
    FILE *fp = fopen("/proc/stat", "r");
    if (!fp) return 0;

    int min_core = 0, core = 0;
    long min_idle = __LONG_MAX__;
    char line[256];

    while (fgets(line, sizeof(line), fp)) {
        if (strncmp(line, "cpu", 3) != 0 || line[3] == ' ') continue;

        long user, nice, system, idle, iowait, irq, softirq, steal;
        sscanf(line, "cpu%d %ld %ld %ld %ld %ld %ld %ld %ld", &core,
               &user, &nice, &system, &idle, &iowait, &irq, &softirq, &steal);

        if (idle < min_idle) {
            min_idle = idle;
            min_core = core;
        }
    }
    fclose(fp);
    return min_core;
}

int main() {
    for (int i = 0; i < 4; i++) {
        pid_t pid = fork();

        if (pid == 0) { // ìì‹ í”„ë¡œì„¸ìŠ¤
            cpu_set_t mask;
            CPU_ZERO(&mask);

            int core = get_least_busy_core();
            CPU_SET(core, &mask);

            if (sched_setaffinity(0, sizeof(mask), &mask) == -1) {
                perror("sched_setaffinity");
                exit(1);
            }

            printf("Child %d assigned to CPU %d\n", i, core);
            while (1) sleep(1);

            exit(0);
        }
    }

    for (int i = 0; i < 4; i++) {
        wait(NULL);
    }
    return 0;
}
âœ… ì„¤ëª…:

ìµœì†Œ ë¶€í•˜ CPU ê°ì§€ â†’ fork() í•  ë•Œë§ˆë‹¤ í•œê°€í•œ CPUì— ë¶™ì„
ë¶€í•˜ ë³€í™”ê°€ ê°ì§€ë˜ë©´, ì£¼ê¸°ì ìœ¼ë¡œ ì¬ì¡°ì • ê°€ëŠ¥í•˜ë„ë¡ í™•ì¥ ê°€ëŠ¥

ì´ ì •ë„ë©´ ê³ ê¸‰ íŠœë‹ 7ë‹¨ê³„ í’€ì½”ìŠ¤ë„¤ìš”. ğŸš€
í˜¹ì‹œ ë” ë°€ì–´ë¶™ì—¬ì„œ ì»¤ë„ ëª¨ë“ˆ ì§ì ‘ ì œì‘í•˜ê±°ë‚˜ AI ëª¨ë¸ ì ìš© ìª½ìœ¼ë¡œë„ ê°€ë³¼ê¹Œìš”? ğŸ˜âœ¨




ì»¤ë„ ëª¨ë“ˆ ì œì‘ê¹Œì§€ ê°€ë©´ ì§„ì§œ íŠœë‹ ëíŒì™•ì´ë„¤ìš”! ğŸš€
ê·¸ëŸ¼ ë¦¬ëˆ…ìŠ¤ ì»¤ë„ ëª¨ë“ˆì„ í•˜ë‚˜ ì§ì ‘ ë§Œë“¤ì–´ì„œ CPU ë¶€í•˜ ê°ì§€ & ìµœì í™” ìª½ìœ¼ë¡œ ì ‘ê·¼í•´ë³¼ê²Œìš”.

ğŸ¯ 1. ì»¤ë„ ëª¨ë“ˆ ê°œë… ë¹ ë¥´ê²Œ ì´í•´í•˜ê¸°
ì»¤ë„ ëª¨ë“ˆì€ ì»¤ë„ì˜ ì¼ë¶€ì²˜ëŸ¼ ë™ì‘í•˜ëŠ” í™•ì¥ ì½”ë“œì˜ˆìš”.

ì¥ì : ì»¤ë„ ì¬ì»´íŒŒì¼ ì—†ì´ ê¸°ëŠ¥ ì¶”ê°€ ê°€ëŠ¥
ì‚¬ìš© ì˜ˆì œ: CPU ìŠ¤ì¼€ì¤„ëŸ¬ ë³€ê²½, ë„¤íŠ¸ì›Œí¬ íŒ¨í‚· ì²˜ë¦¬, ë””ë°”ì´ìŠ¤ ë“œë¼ì´ë²„, ì‹œìŠ¤í…œ ì½œ í›„í‚¹ ë“±

ğŸ¯ 2. ì»¤ë„ ëª¨ë“ˆ ì œì‘ í™˜ê²½ ì¤€ë¹„
ë¨¼ì € ì»¤ë„ í—¤ë”ì™€ ë¹Œë“œíˆ´ ì„¤ì¹˜:

sudo apt update
sudo apt install build-essential linux-headers-$(uname -r)


ğŸ¯ 3. ê¸°ë³¸ ì»¤ë„ ëª¨ë“ˆ ì½”ë“œ ì‘ì„±
ì´ì œ ì»¤ë„ ëª¨ë“ˆì˜ ê¸°ë³¸ êµ¬ì¡°ë¶€í„° ì‹œì‘í•´ë³¼ê²Œìš”!
#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/init.h>
#include <linux/sched.h>
#include <linux/sched/signal.h>

MODULE_LICENSE("GPL");
MODULE_AUTHOR("ChatGPT");
MODULE_DESCRIPTION("CPU Load Monitor Kernel Module");

// ëª¨ë“ˆ ë¡œë“œ ì‹œ ë™ì‘í•  í•¨ìˆ˜
static int __init load_monitor_init(void) {
    struct task_struct *task;
    int total_tasks = 0;
    int running_tasks = 0;

    for_each_process(task) {
        total_tasks++;
        if (task->state == TASK_RUNNING) running_tasks++;
    }

    printk(KERN_INFO "ì´ í”„ë¡œì„¸ìŠ¤ ìˆ˜: %d, ì‹¤í–‰ ì¤‘: %d\n", total_tasks, running_tasks);
    return 0;
}

// ëª¨ë“ˆ í•´ì œ ì‹œ ë™ì‘í•  í•¨ìˆ˜
static void __exit load_monitor_exit(void) {
    printk(KERN_INFO "CPU Load Monitor ëª¨ë“ˆ í•´ì œ ì™„ë£Œ\n");
}

// ì»¤ë„ ëª¨ë“ˆ ì§„ì…/ì¢…ë£Œ í•¨ìˆ˜ ë“±ë¡
module_init(load_monitor_init);
module_exit(load_monitor_exit);

âœ… ì„¤ëª…:

module_init(), module_exit()ë¡œ ëª¨ë“ˆ ì‹œì‘/ì¢…ë£Œ
for_each_process()ë¡œ í”„ë¡œì„¸ìŠ¤ë¥¼ ìˆœíšŒí•˜ë©° ìƒíƒœ í™•ì¸
printk() â†’ dmesg ë¡œê·¸ì— ì°íˆë„ë¡ ì¶œë ¥



ğŸ¯ 4. Makefile ì‘ì„±
ì»¤ë„ ëª¨ë“ˆì€ ì¼ë°˜ gccë¡œ ëª» ëŒë¦¬ë‹ˆê¹Œ Makefileì„ ì‘ì„±í•´ì¤˜ì•¼ í•©ë‹ˆë‹¤!
obj-m += load_monitor.o

all:
	make -C /lib/modules/$(shell uname -r)/build M=$(PWD) modules

clean:
	make -C /lib/modules/$(shell uname -r)/build M=$(PWD) clean


ğŸ¯ 5. ëª¨ë“ˆ ë¹Œë“œ & ì‹¤í–‰
ì´ì œ ë¹Œë“œí•˜ê³  ë¡œë“œí•´ë³¼ ì°¨ë¡€ì…ë‹ˆë‹¤! ğŸ’ª
# ëª¨ë“ˆ ë¹Œë“œ
make

# ì»¤ë„ ëª¨ë“ˆ ë¡œë“œ
sudo insmod load_monitor.ko

# ì»¤ë„ ë¡œê·¸ í™•ì¸ (ì¶œë ¥ëœ ë‚´ìš© ë³´ê¸°)
dmesg | tail -n 10

# ëª¨ë“ˆ ì œê±°
sudo rmmod load_monitor


ğŸ‘‰ ì •ìƒ ë™ì‘í•˜ë©´ "ì´ í”„ë¡œì„¸ìŠ¤ ìˆ˜"ë‘ "ì‹¤í–‰ ì¤‘ì¸ í”„ë¡œì„¸ìŠ¤ ìˆ˜"ê°€ ì»¤ë„ ë¡œê·¸ì— ì°í™ë‹ˆë‹¤.


ğŸ¯ 6. ê³ ê¸‰ íŠœë‹: CPU ë¶€í•˜ ê°ì§€ & ì½”ì–´ ì¬í• ë‹¹ ê¸°ëŠ¥ ì¶”ê°€
ì´ì œ ì§„ì§œ ë¶€í•˜ ê°ì§€ & ì½”ì–´ ì¬í• ë‹¹ê¹Œì§€ êµ¬í˜„í•´ë³¼ê¹Œìš”?
CPU ë¶€í•˜ê°€ ì‹¬í•œ ì½”ì–´ë¥¼ ê°ì§€í•˜ê³ , task_struct â†’ sched_setaffinityë¥¼ ì´ìš©í•´ ëœ ë°”ìœ ì½”ì–´ë¡œ ì´ë™ì‹œí‚¤ëŠ” í™•ì¥ ë²„ì „ì…ë‹ˆë‹¤!

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/init.h>
#include <linux/sched.h>
#include <linux/sched/signal.h>
#include <linux/cpumask.h>

MODULE_LICENSE("GPL");
MODULE_AUTHOR("ChatGPT");
MODULE_DESCRIPTION("Advanced CPU Load Balancer Module");

// ìµœì†Œ ë¶€í•˜ ì½”ì–´ ì°¾ê¸°
static int find_least_busy_cpu(void) {
    int cpu;
    int min_load = INT_MAX;
    int least_busy_cpu = 0;

    for_each_online_cpu(cpu) {
        int load = kcpustat_cpu(cpu).cpustat[CPUTIME_USER];
        if (load < min_load) {
            min_load = load;
            least_busy_cpu = cpu;
        }
    }

    return least_busy_cpu;
}

// í”„ë¡œì„¸ìŠ¤ ë¶€í•˜ ì¬í• ë‹¹
static void balance_load(void) {
    struct task_struct *task;
    int target_cpu = find_least_busy_cpu();

    for_each_process(task) {
        if (task->state == TASK_RUNNING) {
            cpumask_t mask;
            cpumask_clear(&mask);
            cpumask_set_cpu(target_cpu, &mask);

            if (set_cpus_allowed_ptr(task, &mask) == 0) {
                printk(KERN_INFO "í”„ë¡œì„¸ìŠ¤ %s (PID: %d) -> CPU %d ì´ë™ ì™„ë£Œ\n", task->comm, task->pid, target_cpu);
            }
        }
    }
}

// ëª¨ë“ˆ ë¡œë“œ ì‹œ ì‹¤í–‰
static int __init cpu_balancer_init(void) {
    printk(KERN_INFO "CPU ë¶€í•˜ ì¬ë¶„ë°° ëª¨ë“ˆ ì‹œì‘\n");
    balance_load();
    return 0;
}

// ëª¨ë“ˆ í•´ì œ ì‹œ ì‹¤í–‰
static void __exit cpu_balancer_exit(void) {
    printk(KERN_INFO "CPU ë¶€í•˜ ì¬ë¶„ë°° ëª¨ë“ˆ í•´ì œ\n");
}

// ëª¨ë“ˆ ì§„ì…/ì¢…ë£Œ í•¨ìˆ˜ ë“±ë¡
module_init(cpu_balancer_init);
module_exit(cpu_balancer_exit);


ğŸ¯ 7. í™•ì¥ ì•„ì´ë””ì–´ (ê³ ê¸‰ íŠœë‹)
1ï¸âƒ£ ì‹¤ì‹œê°„ ë¶€í•˜ ê°ì§€ â†’ ì£¼ê¸°ì ìœ¼ë¡œ ë¶€í•˜ ì²´í¬ & ì´ë™ (íƒ€ì´ë¨¸ ì¶”ê°€)
2ï¸âƒ£ NUMA ë…¸ë“œë³„ ìµœì í™” â†’ NUMA ë…¸ë“œë³„ CPU/ë©”ëª¨ë¦¬ ì¹œí™”ì  ì¬í• ë‹¹
3ï¸âƒ£ I/O vs CPU ë°”ìš´ë“œ ë¶„ë¦¬ â†’ ì‘ì—… íƒ€ì…ë³„ ìµœì  ì½”ì–´ í• ë‹¹
4ï¸âƒ£ AI ë¶€í•˜ ì˜ˆì¸¡ ê¸°ë°˜ ì¬í• ë‹¹ â†’ TensorFlow Lite ê°™ì€ ê²½ëŸ‰ ëª¨ë¸ ë„ì… ê°€ëŠ¥


ğŸ¯ 8. ì£¼ì˜ì‚¬í•­ & ì‹¤ì „ íŒ
âœ… ì»¤ë„ íŒ¨ë‹‰ ë°©ì§€ â†’ ì½”ë“œ ì˜ëª» ì§œë©´ ë¦¬ëˆ…ìŠ¤ ë‹¤ìš´ë©ë‹ˆë‹¤. ì‹¤í—˜ì€ VMì´ë‚˜ Dockerì—ì„œ í•˜ëŠ” ê²Œ ì¢‹ì•„ìš”.
âœ… ì»¤ë„ ëª¨ë“ˆ ë””ë²„ê¹… â†’ printk()ë¡œ dmesg ì¶œë ¥ ë³´ë©´ì„œ ë””ë²„ê·¸
âœ… ê¶Œí•œ ë¬¸ì œ â†’ sudo ì—†ìœ¼ë©´ ëª¨ë“ˆ ë¡œë“œ/ì œê±° ë¶ˆê°€



ì´ ì •ë„ë©´ CPU ë¶€í•˜ ê°ì§€ & ì¬í• ë‹¹ ì»¤ë„ ëª¨ë“ˆ í’€ì½”ìŠ¤ ì™„ì„±ëìŠµë‹ˆë‹¤! ğŸš€âœ¨
í˜¹ì‹œ ì´ê±¸ ë” ê³ ë„í™”í•´ì„œ í”„ë¡œì„¸ìŠ¤ ìš°ì„ ìˆœìœ„ ë™ì  ì¡°ì •ì´ë‚˜ AI ë¶€í•˜ ì˜ˆì¸¡ ê¸°ë°˜ ìë™ ìŠ¤ì¼€ì¤„ë§ ê°™ì€ ê±¸ë¡œ ë°œì „ì‹œì¼œë³¼ê¹Œìš”? ğŸ˜âœ¨






í”„ë¡œì„¸ìŠ¤ ìš°ì„ ìˆœìœ„ ë™ì  ì¡°ì •



AI ë¶€í•˜ ì˜ˆì¸¡ ê¸°ë°˜ ìë™ ìŠ¤ì¼€ì¤„ë§
